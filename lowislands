-- ✅ Follow Logic with Island Switching (Fixed)
local currentTask
local currentIslandIndex = 1
local islands = {
	"Blizzard Island",
	"Forest Island",
	"The Magical Forest"
}

local function movePlayerToIsland(islandName)
	local players = game:GetService("Players")
	local lp = players.LocalPlayer
	local char = lp.Character or lp.CharacterAdded:Wait()
	
	local islandFolder = workspace.Islands:FindFirstChild(islandName)
	if not islandFolder then
		warn("Island not found:", islandName)
		return false
	end
	
	-- Move the character model into the island folder
	char.Parent = islandFolder
	print("Moved character model to:", islandName)
	
	-- Fire the Travel RemoteEvent to trigger island loading
	local communication = game:GetService("ReplicatedStorage"):FindFirstChild("Communication")
	if communication then
		local functions = communication:FindFirstChild("Functions")
		if functions then
			local travelRemote = functions:FindFirstChild("Travel")
			if travelRemote then
				-- Check if there's a Response RemoteEvent
				local responseRemote = travelRemote:FindFirstChild("Response")
				
				if responseRemote and responseRemote:IsA("RemoteEvent") then
					-- Listen for response
					local responded = false
					local connection
					connection = responseRemote.OnClientEvent:Connect(function(...)
						print("Travel Response received:", ...)
						responded = true
						connection:Disconnect()
					end)
					
					-- Fire the travel request
					if travelRemote:IsA("RemoteEvent") then
						travelRemote:FireServer(islandName)
						print("Fired Travel RemoteEvent for:", islandName)
					elseif travelRemote:IsA("RemoteFunction") then
						local result = travelRemote:InvokeServer(islandName)
						print("Invoked Travel RemoteFunction for:", islandName, "Result:", result)
					end
					
					-- Wait for response with timeout
					local waitTime = 0
					while not responded and waitTime < 5 do
						task.wait(0.1)
						waitTime = waitTime + 0.1
					end
					
					if not responded then
						connection:Disconnect()
						warn("No response received from Travel")
					end
				else
					-- No response remote, just fire normally
					if travelRemote:IsA("RemoteEvent") then
						travelRemote:FireServer(islandName)
						print("Fired Travel RemoteEvent for:", islandName)
					elseif travelRemote:IsA("RemoteFunction") then
						local result = travelRemote:InvokeServer(islandName)
						print("Invoked Travel RemoteFunction for:", islandName, "Result:", result)
					end
				end
			end
		end
	end
	
	task.wait(3) -- Wait for targets to load in
	return true
end

local function followLoopFrom(folder)
	if currentTask then
		task.cancel(currentTask)
	end
	
	local players = game:GetService("Players")
	local lp = players.LocalPlayer
	local char = lp.Character or lp.CharacterAdded:Wait()
	local hrp = char:WaitForChild("HumanoidRootPart")
	
	local function getValidTargets()
		local targets = {}
		for _, model in ipairs(folder:GetChildren()) do
			if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and model:FindFirstChild("maneMesh") then
				table.insert(targets, model)
			end
		end
		return targets
	end
	
	currentTask = task.spawn(function()
		local currentTarget = nil
		local lastSwitch = 0
		local noTargetChecks = 0
		
		while true do
			local now = tick()
			local targets = getValidTargets()
			
			-- Check if no valid targets exist
			if #targets == 0 then
				noTargetChecks = noTargetChecks + 1
				
				if noTargetChecks >= 3 then -- Check 3 times to be sure
					print("No valid targets found in:", islands[currentIslandIndex])
					
					-- Try next island
					currentIslandIndex = currentIslandIndex + 1
					if currentIslandIndex > #islands then
						print("No more islands to check. Restarting from first island.")
						currentIslandIndex = 1
					end
					
					local nextIsland = islands[currentIslandIndex]
					print("Switching to:", nextIsland)
					
					if movePlayerToIsland(nextIsland) then
						local newFolder = workspace.Islands:FindFirstChild(nextIsland)
						if newFolder then
							followLoopFrom(newFolder)
							return -- Exit current loop
						end
					end
					
					noTargetChecks = 0
				end
				
				task.wait(1)
			else
				noTargetChecks = 0 -- Reset counter when targets are found
				
				-- Switch target every 15 seconds or if lost
				if not currentTarget or not currentTarget.Parent or now - lastSwitch >= 15 then
					local newTarget
					repeat
						newTarget = targets[math.random(1, #targets)]
					until newTarget ~= currentTarget or #targets == 1
					
					currentTarget = newTarget
					lastSwitch = now
					
					local targetHRP = currentTarget:FindFirstChild("HumanoidRootPart")
					if targetHRP then
						hrp.CFrame = targetHRP.CFrame * CFrame.new(0, 0, -5)
					end
				end
				
				-- Follow current target
				if currentTarget and currentTarget:FindFirstChild("HumanoidRootPart") then
					local targetHRP = currentTarget.HumanoidRootPart
					local distance = (hrp.Position - targetHRP.Position).Magnitude
					
					if distance > 6 then
						char:PivotTo(CFrame.new(targetHRP.Position + Vector3.new(0, 0, -4)))
					end
					
					if distance > 30 then
						hrp.CFrame = targetHRP.CFrame * CFrame.new(0, 0, -4)
					end
				end
				
				task.wait(0.2)
			end
		end
	end)
end

-- ✅ Auto-start scanning Blizzard Island
followLoopFrom(workspace.Islands["Blizzard Island"])
